"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Input = function () {
  _createClass(Input, null, [{
    key: "Address",
    value: function Address(signal) {
      if (signal.address == null) {
        signal.address = signal.receive.bind(signal);

        return signal.address;
      } else {
        return signal.address;
      }
    }
  }, {
    key: "notify",
    value: function notify(message, addressBook, from, to) {
      try {
        while (from < to) {
          var address = addressBook[from];
          if (address != null) {
            address(message);
          }
          from = from + 1;
        }
      } finally {
        if (from < to) {
          Input.notify(message, addressBook, from + 1, to);
        }
      }
    }
  }, {
    key: "connect",
    value: function connect(signal, address) {
      if (signal.addressBook == null) {
        signal.addressBook = [address];
      } else {
        var addressBook = signal.addressBook;
        if (addressBook.indexOf(address) < 0) {
          addressBook.push(address);
        }
      }
    }
  }]);

  function Input(value) {
    _classCallCheck(this, Input);

    this.value = value;
    this.isBlocked = false;

    this.addressBook = null;
    this.queue = null;
    this.address = null;
  }

  _createClass(Input, [{
    key: "receive",
    value: function receive(value) {
      if (this.isBlocked) {
        if (this.queue == null) {
          this.queue = [value];
        } else {
          this.queue.push(value);
        }
      } else {
        this.isBlocked = true;
        try {
          this.value = value;

          if (this.addressBook != null) {
            var addressBook = this.addressBook;
            Input.notify(value, addressBook, 0, addressBook.length);
          }
        } finally {
          this.isBlocked = false;
          if (this.queue != null && this.queue.length > 0) {
            this.receive(value = this.queue.shift());
          }
        }
      }
    }
  }, {
    key: "subscribe",
    value: function subscribe(address) {
      Input.connect(this, address);
      address(this.value);
    }
  }, {
    key: "connect",
    value: function connect(address) {
      if (this.addressBook == null) {
        this.addressBook = [address];
      } else {
        var addressBook = this.addressBook;
        if (addressBook.indexOf(address) < 0) {
          addressBook.push(address);
        }
      }
    }
  }]);

  return Input;
}();

Input.prototype.$type = "Signal.Signal";

var Inbox = function Inbox(message) {
  _classCallCheck(this, Inbox);

  this.signal = new Input(message);
  this.address = Input.Address(this.signal);
};

Inbox.prototype.$type = "Signal.Mailbox";

var mailbox = exports.mailbox = function mailbox(message) {
  return new Inbox(message);
};

var Forward = function Forward(address, tag) {
  var forward = function forward(message) {
    return address(tag(message));
  };
  forward.to = address;
  forward.tag = tag;
  return forward;
};

if (global['reflex/address'] == null) {
  global['reflex/address'] = 0;
}

var forward = exports.forward = function forward(address, tag) {
  var id = address.id != null ? address.id : address.id = global['reflex/address']++;
  var key = "reflex/address/" + id;

  return tag[key] || (tag[key] = Forward(address, tag));
};

var reductions = exports.reductions = function reductions(step, state, input) {
  var output = new Input(state);
  input.connect(forward(Input.Address(output), function (value) {
    return step(output.value, value);
  }));
  return output;
};

var map = exports.map = function map(f, input) {
  var output = new Input(f(input.value));
  input.connect(forward(Input.Address(output), f));
  return output;
};
//# sourceMappingURL=data:application/json;base64,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R0FBcUIsUUFBUSxFQUFSLEdBQ3BCLFFBQVEsRUFBUixHQUFhLE9BQU8sZ0JBQVAsR0FBYixDQUpNO0FBS2xCLE1BQU0sMEJBQXdCLEVBQXhCLENBTFk7O0FBT2xCLFNBQU8sSUFBSSxHQUFKLE1BQWEsSUFBSSxHQUFKLElBQVcsUUFBUSxPQUFSLEVBQWlCLEdBQWpCLENBQVgsQ0FBYixDQVBXO0NBRnBCOztBQWFLLElBQU0sa0NBQ1gsU0FEVyxVQUNYLENBQUUsSUFBRixFQUNFLEtBREYsRUFFRSxLQUZGLEVBR3VCO0FBQ3JCLE1BQU0sU0FBUyxJQUFJLEtBQUosQ0FBVSxLQUFWLENBQVQsQ0FEZTtBQUVyQixRQUFNLE9BQU4sQ0FBYyxRQUFRLE1BQU0sT0FBTixDQUFjLE1BQWQsQ0FBUixFQUNRO1dBQVMsS0FBSyxPQUFPLEtBQVAsRUFBYyxLQUFuQjtHQUFULENBRHRCLEVBRnFCO0FBSXZCLFNBQU8sTUFBUCxDQUp1QjtDQUh2Qjs7QUFVSyxJQUFNLG9CQUNYLFNBRFcsR0FDWCxDQUFFLENBQUYsRUFDRSxLQURGLEVBRW1CO0FBQ2pCLE1BQU0sU0FBUyxJQUFJLEtBQUosQ0FBVSxFQUFFLE1BQU0sS0FBTixDQUFaLENBQVQsQ0FEVztBQUVqQixRQUFNLE9BQU4sQ0FBYyxRQUFRLE1BQU0sT0FBTixDQUFjLE1BQWQsQ0FBUixFQUErQixDQUEvQixDQUFkLEVBRmlCO0FBR2pCLFNBQU8sTUFBUCxDQUhpQjtDQUZuQiIsImZpbGUiOiJzaWduYWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuXG5cbi8qOjpcbmltcG9ydCB0eXBlIHtBZGRyZXNzLCBTaWduYWwsIE1haWxib3h9IGZyb20gXCIuL3NpZ25hbFwiXG5pbXBvcnQgdHlwZSB7VHJhbnNsYXRlLCBSZWR1Y2VyLCBBZGRyZXNzQm9va30gZnJvbSBcIi4vc2lnbmFsXCJcblxuZXhwb3J0IHR5cGUge1NpZ25hbCwgQWRkcmVzcywgTWFpbGJveH1cbmV4cG9ydCB0eXBlIHtUcmFuc2xhdGUsIFJlZHVjZXIsIEFkZHJlc3NCb29rfVxuKi9cblxuY2xhc3MgSW5wdXQgLyo6OjxhPiovIHtcbiAgLyo6OlxuICAkdHlwZTogXCJTaWduYWwuU2lnbmFsXCI7XG4gIHZhbHVlOiBhO1xuICBhZGRyZXNzQm9vazogP0FkZHJlc3NCb29rPGE+O1xuICBpc0Jsb2NrZWQ6IGJvb2xlYW47XG4gIHF1ZXVlOiA/QXJyYXk8YT47XG4gIGFkZHJlc3M6ID9BZGRyZXNzPGE+O1xuICAqL1xuICBzdGF0aWMgQWRkcmVzcyAvKjo6PG1lc3NhZ2U+Ki8oc2lnbmFsLyo6SW5wdXQ8bWVzc2FnZT4qLykvKjpBZGRyZXNzPG1lc3NhZ2U+Ki97XG4gICAgaWYgKHNpZ25hbC5hZGRyZXNzID09IG51bGwpIHtcbiAgICAgIHNpZ25hbC5hZGRyZXNzID0gc2lnbmFsLnJlY2VpdmUuYmluZChzaWduYWwpXG4gICAgICAvLyBUT0RPOiBTdWJtaXQgYSBidWcgZm9yIGZsb3cgYXMgcmV0dXJuIGhlcmUgYW5kIGVsc2UgY2xhdXNlIGlzXG4gICAgICAvLyByZWR1bmR1bnQuXG4gICAgICByZXR1cm4gc2lnbmFsLmFkZHJlc3NcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNpZ25hbC5hZGRyZXNzXG4gICAgfVxuICB9XG4gIHN0YXRpYyBub3RpZnkobWVzc2FnZS8qOmEqLywgYWRkcmVzc0Jvb2svKjpBZGRyZXNzQm9vazxhPiovLCBmcm9tLyo6bnVtYmVyKi8sIHRvLyo6bnVtYmVyKi8pLyo6dm9pZCovIHtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKGZyb20gPCB0bykge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYWRkcmVzc0Jvb2tbZnJvbV1cbiAgICAgICAgaWYgKGFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgIGFkZHJlc3MobWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgICBmcm9tID0gZnJvbSArIDFcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGZyb20gPCB0bykge1xuICAgICAgICBJbnB1dC5ub3RpZnkobWVzc2FnZSwgYWRkcmVzc0Jvb2ssIGZyb20gKyAxLCB0bylcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIGNvbm5lY3Qoc2lnbmFsLyo6SW5wdXQ8YT4qLywgYWRkcmVzcy8qOkFkZHJlc3M8YT4qLykge1xuICAgIGlmIChzaWduYWwuYWRkcmVzc0Jvb2sgPT0gbnVsbCkge1xuICAgICAgc2lnbmFsLmFkZHJlc3NCb29rID0gW2FkZHJlc3NdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IFN1Ym1pdCBhIGZsb3cgYnVnIHRoYXQgc2VlbXMgdG8gb2NjdXIgaWYgb2JzZXJ2ZXJzIGFyZW4ndCBjb3B5aWVkXG4gICAgICAvLyBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgYXNzdW1lcyB0aGF0IGB0aGlzLm9ic2VydmVyLmluZGV4T2Yob2JzZXJ2ZXIpYFxuICAgICAgLy8gbWF5IG11dGF0ZSB0aGlzLlxuICAgICAgY29uc3QgYWRkcmVzc0Jvb2sgPSBzaWduYWwuYWRkcmVzc0Jvb2tcbiAgICAgIGlmIChhZGRyZXNzQm9vay5pbmRleE9mKGFkZHJlc3MpIDwgMCkge1xuICAgICAgICBhZGRyZXNzQm9vay5wdXNoKGFkZHJlc3MpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKHZhbHVlLyo6YSovKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5pc0Jsb2NrZWQgPSBmYWxzZVxuXG4gICAgdGhpcy5hZGRyZXNzQm9vayA9IG51bGxcbiAgICB0aGlzLnF1ZXVlID0gbnVsbFxuICAgIHRoaXMuYWRkcmVzcyA9IG51bGxcbiAgfVxuICByZWNlaXZlKHZhbHVlLyo6YSovKSB7XG4gICAgLy8gSWYgc2lnbmFsIGlzIGJsb2NrZWQgcXVldWUgdHJhbnNhY3Rpb24gdG8gYmUgcHJvY2Vzc2VkIG9uY2UgaXQgaXNcbiAgICAvLyB1bmJsb2NrZWQuXG4gICAgaWYgKHRoaXMuaXNCbG9ja2VkKSB7XG4gICAgICBpZiAodGhpcy5xdWV1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucXVldWUgPSBbdmFsdWVdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2godmFsdWUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNCbG9ja2VkID0gdHJ1ZVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlXG5cbiAgICAgICAgaWYgKHRoaXMuYWRkcmVzc0Jvb2sgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGFkZHJlc3NCb29rID0gdGhpcy5hZGRyZXNzQm9va1xuICAgICAgICAgIElucHV0Lm5vdGlmeSh2YWx1ZSwgYWRkcmVzc0Jvb2ssIDAsIGFkZHJlc3NCb29rLmxlbmd0aClcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5pc0Jsb2NrZWQgPSBmYWxzZVxuICAgICAgICBpZiAodGhpcy5xdWV1ZSAhPSBudWxsICYmIHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMucmVjZWl2ZSh2YWx1ZSA9IHRoaXMucXVldWUuc2hpZnQoKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdWJzY3JpYmUoYWRkcmVzcy8qOkFkZHJlc3M8YT4qLykvKjp2b2lkKi8ge1xuICAgIElucHV0LmNvbm5lY3QodGhpcywgYWRkcmVzcylcbiAgICBhZGRyZXNzKHRoaXMudmFsdWUpXG4gIH1cbiAgY29ubmVjdChhZGRyZXNzLyo6QWRkcmVzczxhPiovKSB7XG4gICAgaWYgKHRoaXMuYWRkcmVzc0Jvb2sgPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRyZXNzQm9vayA9IFthZGRyZXNzXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBTdWJtaXQgYSBmbG93IGJ1ZyB0aGF0IHNlZW1zIHRvIG9jY3VyIGlmIG9ic2VydmVycyBhcmVuJ3QgY29weWllZFxuICAgICAgLy8gcHJlc3VtYWJseSBiZWNhdXNlIGl0IGFzc3VtZXMgdGhhdCBgdGhpcy5vYnNlcnZlci5pbmRleE9mKG9ic2VydmVyKWBcbiAgICAgIC8vIG1heSBtdXRhdGUgdGhpcy5cbiAgICAgIGNvbnN0IGFkZHJlc3NCb29rID0gdGhpcy5hZGRyZXNzQm9va1xuICAgICAgaWYgKGFkZHJlc3NCb29rLmluZGV4T2YoYWRkcmVzcykgPCAwKSB7XG4gICAgICAgIGFkZHJlc3NCb29rLnB1c2goYWRkcmVzcylcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbklucHV0LnByb3RvdHlwZS4kdHlwZSA9IFwiU2lnbmFsLlNpZ25hbFwiXG5cbmNsYXNzIEluYm94IC8qOjo8bWVzc2FnZT4qLyB7XG4gIC8qOjpcbiAgJHR5cGU6IFwiU2lnbmFsLk1haWxib3hcIjtcbiAgc2lnbmFsOiBTaWduYWw8bWVzc2FnZT47XG4gIGFkZHJlc3M6IEFkZHJlc3M8bWVzc2FnZT47XG4gICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UvKjptZXNzYWdlKi8pIHtcbiAgICB0aGlzLnNpZ25hbCA9IG5ldyBJbnB1dChtZXNzYWdlKVxuICAgIHRoaXMuYWRkcmVzcyA9IElucHV0LkFkZHJlc3ModGhpcy5zaWduYWwpXG4gIH1cbn1cbkluYm94LnByb3RvdHlwZS4kdHlwZSA9IFwiU2lnbmFsLk1haWxib3hcIlxuXG5leHBvcnQgY29uc3QgbWFpbGJveCA9IC8qOjo8bWVzc2FnZT4qL1xuICAobWVzc2FnZS8qOm1lc3NhZ2UqLykvKjpNYWlsYm94PG1lc3NhZ2U+Ki8gPT5cbiAgbmV3IEluYm94KG1lc3NhZ2UpXG5cblxuY29uc3QgRm9yd2FyZCA9IC8qOjo8YSxiPiovXG4gICggYWRkcmVzcy8qOkFkZHJlc3M8Yj4qL1xuICAsIHRhZy8qOihhOmEpPT5iKi9cbiAgKS8qOkFkZHJlc3M8YT4qLyA9PiB7XG4gICAgY29uc3QgZm9yd2FyZCA9IChtZXNzYWdlLyo6YSovKSA9PiBhZGRyZXNzKHRhZyhtZXNzYWdlKSlcbiAgICBmb3J3YXJkLnRvID0gYWRkcmVzc1xuICAgIGZvcndhcmQudGFnID0gdGFnXG4gICAgcmV0dXJuIGZvcndhcmRcbiAgfVxuXG5pZiAoZ2xvYmFsWydyZWZsZXgvYWRkcmVzcyddID09IG51bGwpIHtcbiAgZ2xvYmFsWydyZWZsZXgvYWRkcmVzcyddID0gMFxufVxuXG4vLyBDcmVhdGUgYSBuZXcgYWRkcmVzcy4gVGhpcyBhZGRyZXNzIHdpbGwgdGFnIGVhY2ggbWVzc2FnZSBpdCByZWNlaXZlcyBhbmQgdGhlblxuLy8gZm9yd2FyZCBpdCBhbG9uZyB0byB0aGUgZ2l2ZW4gYWRkcmVzcy5cbi8vIEV4YW1wbGU6XG4vL1xuLy8gY29uc3QgUmVtb3ZlID0gdGFyZ2V0ID0+IHt0eXBlOiBcIlJlbW92ZVwiLCB0YXJnZXR9XG4vLyByZW1vdmVBZGRyZXNzID0gZm9yd2FyZChhZGRyZXNzLCBSZW1vdmUpXG4vL1xuLy8gQWJvdmUgZXhhbXBsZSBjcmVhdGVkIGByZW1vdmVBZGRyZXNzYCB0YWdzIGVhY2ggbWVzc2FnZSB3aXRoIGBSZW1vdmVgIHRhZ1xuLy8gYmVmb3JlIGZvcndhcmRpbmcgdGhlbSB0byBhIGdlbmVyYWwgYGFkZHJlc3NgLlxuZXhwb3J0IGNvbnN0IGZvcndhcmQgPSAvKjo6PGEsIGI+Ki9cbiAgKCBhZGRyZXNzLyo6QWRkcmVzczxhPiovXG4gICwgdGFnLyo6VHJhbnNsYXRlPGIsIGE+Ki9cbiAgKS8qOkFkZHJlc3M8Yj4qLyA9PiB7XG4gICAgLy8gR2VucmF0ZSBJRCBmb3IgZWFjaCBhZGRyZXNzIHRoYXQgaGFzIGEgZm9yd2FyZGluZyBhZGRyZXNzZXMgc28gdGhhdFxuICAgIC8vIGZvcndhcmRpbmcgYWRkcmVzc2VzIGNvdWxkIGJlIGNhY2hlZCBieSB0aGF0IGlkIGFuZCBhIHRhZy1pbmcgZnVuY3Rpb24uXG4gICAgY29uc3QgaWQgPSBhZGRyZXNzLmlkICE9IG51bGwgPyBhZGRyZXNzLmlkIDpcbiAgICAgICAgICAgICAgIChhZGRyZXNzLmlkID0gZ2xvYmFsWydyZWZsZXgvYWRkcmVzcyddKyspO1xuICAgIGNvbnN0IGtleSA9IGByZWZsZXgvYWRkcmVzcy8ke2lkfWBcblxuICAgIHJldHVybiB0YWdba2V5XSB8fCAodGFnW2tleV0gPSBGb3J3YXJkKGFkZHJlc3MsIHRhZykpXG4gIH1cblxuXG5leHBvcnQgY29uc3QgcmVkdWN0aW9ucyA9IC8qOjo8c3RhdGUsIGlucHV0PiovXG4gICggc3RlcC8qOlJlZHVjZXI8c3RhdGUsIGlucHV0PiovXG4gICwgc3RhdGUvKjpzdGF0ZSovXG4gICwgaW5wdXQvKjpTaWduYWw8aW5wdXQ+Ki9cbiAgKS8qOlNpZ25hbDxzdGF0ZT4qLyA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gbmV3IElucHV0KHN0YXRlKVxuICAgIGlucHV0LmNvbm5lY3QoZm9yd2FyZChJbnB1dC5BZGRyZXNzKG91dHB1dCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0+IHN0ZXAob3V0cHV0LnZhbHVlLCB2YWx1ZSkpKVxuICByZXR1cm4gb3V0cHV0XG59XG5cbmV4cG9ydCBjb25zdCBtYXAgPSAvKjo6PGEsIGI+Ki9cbiAgKCBmLyo6VHJhbnNsYXRlPGEsIGI+Ki9cbiAgLCBpbnB1dC8qOlNpZ25hbDxhPiovXG4gICkvKjpTaWduYWw8Yj4qLyA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gbmV3IElucHV0KGYoaW5wdXQudmFsdWUpKVxuICAgIGlucHV0LmNvbm5lY3QoZm9yd2FyZChJbnB1dC5BZGRyZXNzKG91dHB1dCksIGYpKVxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxuIl19