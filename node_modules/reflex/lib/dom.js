"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var driver = null;

var VirtualRoot = function () {
  function VirtualRoot(view, model, address) {
    _classCallCheck(this, VirtualRoot);

    this.view = view;
    this.model = model;
    this.address = address;
  }

  _createClass(VirtualRoot, [{
    key: "renderWith",
    value: function renderWith(current) {
      var previous = driver;
      driver = current;

      try {
        driver.render(this.view(this.model, this.address));
      } finally {
        driver = previous;
      }
    }
  }]);

  return VirtualRoot;
}();

VirtualRoot.prototype.$type = "VirtualRoot";

var LazyNode = exports.LazyNode = function () {
  function LazyNode(tagName, properties, children) {
    _classCallCheck(this, LazyNode);

    this.tagName = tagName;
    this.properties = properties;
    this.children = children;
    this.key = properties == null ? null : properties.key;
  }

  _createClass(LazyNode, [{
    key: "force",
    value: function force() {
      if (driver == null) {
        throw TypeError('LazyTree may only be forced from with in the Root.renderWith(driver) call');
      }

      return driver.node(this.tagName, this.properties, this.children);
    }
  }]);

  return LazyNode;
}();

LazyNode.prototype.$type = "LazyTree";

var LazyThunk = function () {
  function LazyThunk(key, view, args) {
    _classCallCheck(this, LazyThunk);

    this.key = key;
    this.view = view;
    this.args = args;
  }

  _createClass(LazyThunk, [{
    key: "force",
    value: function force() {
      var _driver;

      if (driver == null) {
        throw TypeError('LazyTree may only be forced from with in the Root.renderWith(driver) call');
      }

      return (_driver = driver).thunk.apply(_driver, [this.key, this.view].concat(_toConsumableArray(this.args)));
    }
  }]);

  return LazyThunk;
}();

LazyThunk.prototype.$type = "LazyTree";

var root = exports.root = function root(view, model, address) {
  return new VirtualRoot(view, model, address);
};

var text = exports.text = function text(content) {
  return driver == null ? content : driver.text == null ? content : driver.text(content);
};

var node = exports.node = function node(tagName, properties, children) {
  return driver == null ? new LazyNode(tagName, properties, children) : driver.node(tagName, properties, children);
};

var thunk = exports.thunk = function thunk(key, view) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var _driver2;

  return driver == null ? new LazyThunk(key, view, args) : (_driver2 = driver).thunk.apply(_driver2, [key, view].concat(args));
};
//# sourceMappingURL=data:application/json;base64,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LENBQUUsR0FBRixFQUNFLElBREY7b0NBRUs7Ozs7OztTQUVILFVBQVUsSUFBVixHQUNBLElBQUksU0FBSixDQUFjLEdBQWQsRUFBbUIsSUFBbkIsRUFBeUIsSUFBekIsQ0FEQSxHQUVBLG9CQUFPLEtBQVAsa0JBQWEsS0FBSyxhQUFTLEtBQTNCLENBRkE7Q0FKRiIsImZpbGUiOiJkb20uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuXG4vKjo6XG5pbXBvcnQgdHlwZSB7VGV4dCwgS2V5LCBUYWdOYW1lLCBQcm9wZXJ0eURpY3Rpb25hcnl9IGZyb20gXCIuL2NvcmVcIlxuaW1wb3J0IHR5cGUge1ZpcnR1YWxUZXh0LCBWaXJ0dWFsTm9kZSwgVmlydHVhbFRyZWUsIExhenlUcmVlLCBUaHVua30gZnJvbSBcIi4vY29yZVwiXG5pbXBvcnQgdHlwZSB7RHJpdmVyfSBmcm9tIFwiLi9kcml2ZXJcIlxuaW1wb3J0IHR5cGUge0FkZHJlc3N9IGZyb20gXCIuL3NpZ25hbFwiXG5cbmV4cG9ydCB0eXBlIHtUZXh0LCBLZXksIFRhZ05hbWV9XG4qL1xuXG5sZXQgZHJpdmVyLyo6P0RyaXZlciovID0gbnVsbFxuXG5jbGFzcyBWaXJ0dWFsUm9vdCAvKjo6PG1vZGVsLCBhY3Rpb24+Ki8ge1xuICAvKjo6XG4gICR0eXBlOiBcIlZpcnR1YWxSb290XCI7XG5cbiAgdmlldzogKG1vZGVsOm1vZGVsLCBhZGRyZXNzOkFkZHJlc3M8YWN0aW9uPikgPT4gVmlydHVhbFRyZWU7XG4gIG1vZGVsOiBtb2RlbDtcbiAgYWRkcmVzczogQWRkcmVzczxhY3Rpb24+O1xuICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICB2aWV3Lyo6KG1vZGVsOm1vZGVsLCBhZGRyZXNzOkFkZHJlc3M8YWN0aW9uPikgPT4gVmlydHVhbFRyZWUqL1xuICAsIG1vZGVsLyo6bW9kZWwqL1xuICAsIGFkZHJlc3MvKjpBZGRyZXNzPGFjdGlvbj4qL1xuICApIHtcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsXG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzc1xuICB9XG4gIHJlbmRlcldpdGgoY3VycmVudC8qOkRyaXZlciovKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSBkcml2ZXJcbiAgICBkcml2ZXIgPSBjdXJyZW50XG5cbiAgICB0cnkge1xuICAgICAgZHJpdmVyLnJlbmRlcih0aGlzLnZpZXcodGhpcy5tb2RlbCwgdGhpcy5hZGRyZXNzKSlcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZHJpdmVyID0gcHJldmlvdXNcbiAgICB9XG4gIH1cbn1cblZpcnR1YWxSb290LnByb3RvdHlwZS4kdHlwZSA9IFwiVmlydHVhbFJvb3RcIlxuXG5leHBvcnQgY2xhc3MgTGF6eU5vZGUge1xuICAvKjo6XG4gICR0eXBlOiBcIkxhenlUcmVlXCI7XG5cbiAgdGFnTmFtZTogVGFnTmFtZTtcbiAgcHJvcGVydGllczogP1Byb3BlcnR5RGljdGlvbmFyeTtcbiAgY2hpbGRyZW46ID9BcnJheTxWaXJ0dWFsVHJlZT47XG4gIGtleTogP0tleTtcbiAgbmFtZXNwYWNlOiBzdHJpbmc7XG4gICovXG4gIGNvbnN0cnVjdG9yKHRhZ05hbWUvKjpUYWdOYW1lKi8sIHByb3BlcnRpZXMvKjo/UHJvcGVydHlEaWN0aW9uYXJ5Ki8sIGNoaWxkcmVuLyo6P0FycmF5PFZpcnR1YWxUcmVlPiovKSB7XG4gICAgdGhpcy50YWdOYW1lID0gdGFnTmFtZVxuICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW5cbiAgICB0aGlzLmtleSA9IHByb3BlcnRpZXMgPT0gbnVsbCA/IG51bGwgOiBwcm9wZXJ0aWVzLmtleVxuICB9XG4gIGZvcmNlKCkvKjpWaXJ0dWFsTm9kZSovIHtcbiAgICBpZiAoZHJpdmVyID09IG51bGwpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTGF6eVRyZWUgbWF5IG9ubHkgYmUgZm9yY2VkIGZyb20gd2l0aCBpbiB0aGUgUm9vdC5yZW5kZXJXaXRoKGRyaXZlcikgY2FsbCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRyaXZlci5ub2RlKHRoaXMudGFnTmFtZSwgdGhpcy5wcm9wZXJ0aWVzLCB0aGlzLmNoaWxkcmVuKVxuICB9XG59XG5MYXp5Tm9kZS5wcm90b3R5cGUuJHR5cGUgPSBcIkxhenlUcmVlXCI7XG5cbmNsYXNzIExhenlUaHVuayB7XG4gIC8qOjpcbiAgJHR5cGU6IFwiTGF6eVRyZWVcIjtcblxuICBrZXk6IEtleTtcbiAgdmlldzogRnVuY3Rpb247XG4gIGFyZ3M6IEFycmF5PGFueT47XG4gICovXG4gIGNvbnN0cnVjdG9yKGtleS8qOktleSovLCB2aWV3Lyo6RnVuY3Rpb24qLywgYXJncy8qOkFycmF5PGFueT4qLykge1xuICAgIHRoaXMua2V5ID0ga2V5XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMuYXJncyA9IGFyZ3NcbiAgfVxuICBmb3JjZSgpLyo6VGh1bmsqLyB7XG4gICAgaWYgKGRyaXZlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0xhenlUcmVlIG1heSBvbmx5IGJlIGZvcmNlZCBmcm9tIHdpdGggaW4gdGhlIFJvb3QucmVuZGVyV2l0aChkcml2ZXIpIGNhbGwnKVxuICAgIH1cblxuICAgIHJldHVybiBkcml2ZXIudGh1bmsodGhpcy5rZXksIHRoaXMudmlldywgLi4udGhpcy5hcmdzKVxuICB9XG59XG5MYXp5VGh1bmsucHJvdG90eXBlLiR0eXBlID0gXCJMYXp5VHJlZVwiO1xuXG5leHBvcnQgY29uc3Qgcm9vdCA9IC8qOjo8bW9kZWwsIGFjdGlvbj4qL1xuICAoIHZpZXcvKjoobW9kZWw6bW9kZWwsIGFkZHJlc3M6QWRkcmVzczxhY3Rpb24+KSA9PiBWaXJ0dWFsVHJlZSovXG4gICwgbW9kZWwvKjptb2RlbCovXG4gICwgYWRkcmVzcy8qOkFkZHJlc3M8YWN0aW9uPiovXG4gICkvKjpWaXJ0dWFsUm9vdCovID0+XG4gIG5ldyBWaXJ0dWFsUm9vdFxuICAoIHZpZXdcbiAgLCBtb2RlbFxuICAsIGFkZHJlc3NcbiAgKVxuXG5leHBvcnQgY29uc3QgdGV4dCA9XG4gIChjb250ZW50Lyo6VGV4dCovKS8qOlRleHQgfCBWaXJ0dWFsVGV4dCovID0+XG4gICggZHJpdmVyID09IG51bGxcbiAgPyBjb250ZW50XG4gIDogZHJpdmVyLnRleHQgPT0gbnVsbFxuICA/IGNvbnRlbnRcbiAgOiBkcml2ZXIudGV4dChjb250ZW50KVxuICApXG5cbmV4cG9ydCBjb25zdCBub2RlID1cbiAgKCB0YWdOYW1lLyo6VGFnTmFtZSovXG4gICwgcHJvcGVydGllcy8qOj9Qcm9wZXJ0eURpY3Rpb25hcnkqL1xuICAsIGNoaWxkcmVuLyo6P0FycmF5PFZpcnR1YWxUcmVlPiovXG4gICkvKjpWaXJ0dWFsTm9kZSB8IExhenlUcmVlPFZpcnR1YWxOb2RlPiovID0+XG4gICggZHJpdmVyID09IG51bGxcbiAgPyBuZXcgTGF6eU5vZGUodGFnTmFtZSwgcHJvcGVydGllcywgY2hpbGRyZW4pXG4gIDogZHJpdmVyLm5vZGUodGFnTmFtZSwgcHJvcGVydGllcywgY2hpbGRyZW4pXG4gIClcblxuZXhwb3J0IGNvbnN0IHRodW5rID0gLyo6OjxhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqPiovXG4gICgga2V5Lyo6c3RyaW5nKi9cbiAgLCB2aWV3Lyo6KGE6YSwgYjpiLCBjOmMsIGQ6ZCwgZTplLCBmOmYsIGc6ZywgaDpoLCBpOmksIGo6aikgPT4gVmlydHVhbFRyZWUqL1xuICAsIC4uLmFyZ3MvKjpBcnJheTxhbnk+Ki9cbiAgKS8qOlRodW5rIHwgTGF6eVRyZWU8VGh1bms+Ki8gPT5cbiAgKCBkcml2ZXIgPT0gbnVsbFxuICA/IG5ldyBMYXp5VGh1bmsoa2V5LCB2aWV3LCBhcmdzKVxuICA6IGRyaXZlci50aHVuayhrZXksIHZpZXcsIC4uLmFyZ3MpXG4gIClcbiJdfQ==